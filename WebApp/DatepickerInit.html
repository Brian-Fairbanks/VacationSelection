<script>
    // Global variables initialized in DatepickerInit
    let currentDayCount = 1;
    const MAX_DAYS = 30;
    defaultStartDate = new Date('2026-02-04')
    endSelectDate = new Date('2027-01-01')
    // Global list to track all selected block start dates
    let allSelectedBlockStarts = {};

    // Track which input is currently opening the datepicker
    let currentOpenInputId = null;

    /**
     * Generates the HTML string for a new day selection block.
     * NOTE: We remove the 'disabled' check from the template since it's now handled
     * dynamically in onSelect whenever a date is picked.
     */
    function createDayBlock(dayNum) {
        return `
        <div id="day-${dayNum}-selection" class="flex flex-col sm:flex-row gap-4 sm:gap-8 items-start sm:items-end py-4 border-t mt-4 day-selection-block" style="display: none;">
                
                <div class="flex-1 min-w-0">
                        <label for="day${dayNum}-date" class="block text-base font-medium text-gray-700 mb-1">Date</label>
                        <div class="flex items-center space-x-2">
                                <input type="text" id="day${dayNum}-date" name="day${dayNum}Date" class="datepicker w-full mt-1 p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500" placeholder="MM/DD/YYYY">
                                <span id="day${dayNum}-shift-feedback" class="text-xs px-2 py-1 rounded-full font-semibold border border-transparent transition-all duration-300 whitespace-nowrap"></span>
                        </div>
                        <p class="text-xs text-gray-500 mt-1">MM-DD-YYYY (Click input for calendar)</p>
                </div>

                <div class="shrink-0">
                        <label class="block text-base font-medium text-gray-700 mb-1">Shift Selection ${dayNum}</label>
                        <div class="flex space-x-4">
                                <div class="flex items-center">
                                        <input id="day${dayNum}-shift-day1" name="day${dayNum}Shift" type="checkbox" value="Day1" checked class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                                        <label for="day${dayNum}-shift-day1" class="ml-2 text-sm font-medium text-gray-700">Day 1</label>
                                </div>
                                <div class="flex items-center">
                                        <input id="day${dayNum}-shift-day2" name="day${dayNum}Shift" type="checkbox" value="Day2" checked class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                                        <label for="day${dayNum}-shift-day2" class="ml-2 text-sm font-medium text-gray-700">Day 2</label>
                                </div>
                        </div>
                </div>
        </div>
        `;
    }

    /**
     * This function contains your complex datepicker configuration.
     */
    function applyComplexDatepicker(inputElement) {

        $(inputElement).datepicker({
            dateFormat: 'mm/dd/yy',
            defaultDate: defaultStartDate,
            maxDate: endSelectDate,

            // Your hover logic (unchanged)
            beforeShow: function (input, inst) {
                // Track which input is currently open
                currentOpenInputId = this.id;
                console.log("Opened datepicker for:", currentOpenInputId, "with value:", this.value);

                setTimeout(function () {
                    $('.ui-datepicker-calendar a').off('mouseenter mouseleave')
                        .on('mouseenter', function () {
                            const tdElement = $(this).closest('td');
                            const dayNum = parseInt($(this).text(), 10);
                            const linkMonth = parseInt(tdElement.attr('data-month'), 10);
                            const linkYear = parseInt(tdElement.attr('data-year'), 10);
                            if (isNaN(dayNum) || isNaN(linkMonth) || isNaN(linkYear)) return;
                            const linkDate = new Date(linkYear, linkMonth, dayNum);
                            const { blockStartDate } = getShiftAndBlock(linkDate);
                            toggleBlockHover(blockStartDate, 'add');
                        })
                        .on('mouseleave', function () {
                            const tdElement = $(this).closest('td');
                            const dayNum = parseInt($(this).text(), 10);
                            const linkMonth = parseInt(tdElement.attr('data-month'), 10);
                            const linkYear = parseInt(tdElement.attr('data-year'), 10);
                            if (isNaN(dayNum) || isNaN(linkMonth) || isNaN(linkYear)) return;
                            const linkDate = new Date(linkYear, linkMonth, dayNum);
                            const { blockStartDate } = getShiftAndBlock(linkDate);
                            toggleBlockHover(blockStartDate, 'remove');
                        });
                }, 0);
            },

            // --- onSelect (Modified for Checkbox Disabling) ---
            onSelect: function (dateText, inst) {
                const selectedDate = new Date(inst.selectedYear, inst.selectedMonth, inst.selectedDay);
                const { blockStartDate, shift } = getShiftAndBlock(selectedDate);
                const $input = $(this);
                const dayNum = parseInt(this.id.match(/^day(\d+)-date$/)[1]);
                const userAssignedShift = window.USER_INFO ? window.USER_INFO.shift : null;
                // console.log(`selectedDate:${selectedDate}, dayNum:${dayNum}, input:${$input} `);
                if (blockStartDate) {
                    
                    //  All Block Methods 
                    allSelectedBlockStarts[dayNum] = blockStartDate;

                    const formattedDate = formatDate(blockStartDate);
                    $input.val(formattedDate);

                    // Refresh ALL datepickers to show the new global state
                    $('.datepicker').datepicker('refresh');
                      collapseEmptyRows();

                    // Update the feedback span for *this* input

                    const $feedback = $(`#day${dayNum}-shift-feedback`);
                    const { block } = getShiftAndBlock(blockStartDate);
                }

                // Add new day logic 
                if (dayNum === currentDayCount && currentDayCount < MAX_DAYS) {
                    addNewDayBlock();
                }
            },

            // --- beforeShowDay (Modified for Calendar Day Disabling) ---
            beforeShowDay: function (date) {
                const { class: shiftClass, blockStartDate, shift: currentShift } = getShiftAndBlock(date);
                let extraClass = shiftClass;

                const userAssignedShift = window.USER_INFO ? window.USER_INFO.shift : null;
                let isSelectable = true;
                let isGloballyBooked = false;

                // Get the current input's ID and day number from our tracked variable
                const currentInputId = currentOpenInputId;
                const currentDayNumMatch = currentInputId ? currentInputId.match(/^day(\d+)-date$/) : null;
                const currentDayNum = currentDayNumMatch ? parseInt(currentDayNumMatch[1]) : null;

                // Get the current input's selected date value
                const currentInputValue = currentInputId ? $(`#${currentInputId}`).val() : '';

                // Safety check for shift restriction
                if (!currentInputId) {
                    // Datepicker not fully initialized yet
                    if (userAssignedShift && currentShift && currentShift !== userAssignedShift) {
                        return [false, shiftClass, `Shift ${currentShift}`];
                    }
                    return [true, shiftClass, `Shift ${currentShift}`];
                }

                // 1. SHIFT RESTRICTION CHECK: Disable days that don't match the user's shift
                if (userAssignedShift && currentShift && currentShift !== userAssignedShift) {
                    isSelectable = false;
                }


                // 2. GLOBAL BOOKING CHECK & HIGHLIGHT LOGIC
                const currentDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());

                for (const dayKey in allSelectedBlockStarts) {
                    const selectedBlockStartDate = allSelectedBlockStarts[dayKey];
                    if (!selectedBlockStartDate) continue;

                    // --- KEY MODIFICATION: Skip checking the dates selected by the current input ---
                    if (parseInt(dayKey) === currentDayNum) {
                        continue;
                    }

                    // Calculate the two days of the globally selected block
                    const selectedDay1 = new Date(selectedBlockStartDate.getFullYear(), selectedBlockStartDate.getMonth(), selectedBlockStartDate.getDate());
                    const selectedDay2 = new Date(selectedDay1);
                    selectedDay2.setDate(selectedDay2.getDate() + 1);

                    // Check if the current calendar day matches any OTHER selected block
                    const isDay1Match = currentDate.getTime() === selectedDay1.getTime();
                    const isDay2Match = currentDate.getTime() === selectedDay2.getTime();

                    if (isDay1Match || isDay2Match) {
                        isGloballyBooked = true;
                        extraClass += ' ui-state-highlight ui-state-active selected-shift-day globally-booked-disabled';
                        break;
                    }
                }

                // 3. ENFORCEMENT: If the day is part of an already selected block (by a *different* input), make it UNSELECTABLE
                if (isGloballyBooked) {
                    isSelectable = false;
                }


                // 4. BLOCK STYLING (Unchanged)
                if (blockStartDate) {
                    const secondDay = new Date(blockStartDate.getFullYear(), blockStartDate.getMonth(), blockStartDate.getDate());
                    secondDay.setDate(secondDay.getDate() + 1);
                    const isBlockStart = currentDate.getTime() === blockStartDate.getTime();
                    const isBlockSecondDay = currentDate.getTime() === secondDay.getTime();
                    const firstDayIsWeekend = blockStartDate.getDay() === 0 || blockStartDate.getDay() === 6;
                    const secondDayIsWeekend = secondDay.getDay() === 0 || secondDay.getDay() === 6;
                    const bothDaysWeekend = firstDayIsWeekend && secondDayIsWeekend;

                    if (isBlockStart) { extraClass += ' shift-block-start'; if (bothDaysWeekend) extraClass += ' both-days-weekend'; }
                    if (isBlockSecondDay) { extraClass += ' shift-block-end'; if (bothDaysWeekend) extraClass += ' both-days-weekend'; }
                }

                // 5. CURRENT INPUT'S SELECTION (Your logic, fixed)
                // 'date' is the calendar day. 'currentSelectionDate' is the specific day from the calendar
                const currentSelectionDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());

                // Get the date string from your global variable
                const myGlobalDateString = window.selectedDate;

                if (myGlobalDateString) { // Check if it's not ""
                    try {
                        // Create a Date object from the global string (e.g., "02/12/2026")
                        const dateParts = myGlobalDateString.split('/');
                        const mySelectedBlock = new Date(dateParts[2], dateParts[0] - 1, dateParts[1]);

                        // Calculate the two days of the block
                        const selectedDay1 = new Date(mySelectedBlock.getFullYear(), mySelectedBlock.getMonth(), mySelectedBlock.getDate());
                        const selectedDay2 = new Date(selectedDay1);
                        selectedDay2.setDate(selectedDay2.getDate() + 1);

                        // --- THIS IS THE FIX ---
                        // Compare the CALENDAR DAY (currentDate) to the GLOBAL block
                        const isDay1Match = currentDate.getTime() === selectedDay1.getTime();
                        const isDay2Match = currentDate.getTime() === selectedDay2.getTime();

                        if (isDay1Match || isDay2Match) {
                            // It's a match, so highlight and "unlock" it
                            extraClass += ' ui-state-highlight ui-state-active selected-shift-day ui-datepicker-current-day';
                            extraClass = extraClass.replace('globally-booked-disabled', '');
                            isSelectable = true; // Override any previous 'false'
                        }
                    } catch (e) {
                        // This will catch "Invalid Date" errors if the string is bad
                    }
                }

                // Return [isSelectable, extraClass, title]
                return [isSelectable, extraClass, `Shift ${currentShift}`];
            }
        });

        // Handle clearing an input
        $(inputElement).on('change', function() {
        const $input = $(this);
        const dayNum = parseInt(this.id.match(/^day(\d+)-date$/)[1]);
        
        // The core validation now runs here
        enforceCheckboxState($input, dayNum);
        collapseEmptyRows();
        });
    }

/**
 * Handles creating the new block, initializing its datepicker, and showing it.
 */
function addNewDayBlock() {
    currentDayCount++;
    const newBlockHtml = createDayBlock(currentDayCount);
    const $newBlock = $(newBlockHtml);
    $('#day-selection-container').append($newBlock);

    // Apply the complex datepicker to the new input
    const newInput = $newBlock.find('.datepicker');
    applyComplexDatepicker(newInput);

    $newBlock.slideDown(200);
}

// In DatepickerInit.html

function enforceCheckboxState($input, dayNum) {
    const dateText = $input.val();
    const $shiftCheckboxes = $(`input[name="day${dayNum}Shift"]`);
    const $feedback = $(`#day${dayNum}-shift-feedback`);
    
    // Default class removal to reset validation styling
    $input.removeClass('border-red-500 border-green-500'); 
    $feedback.removeClass('bg-red-200 bg-blue-200 bg-orange-200 text-red-800 text-blue-800 text-orange-800 border-red-400 border-blue-400 border-orange-400 border');
    
    // 1. Handle the "clear" case (if input is empty)
    if (!dateText) {
        $shiftCheckboxes.prop('disabled', false).prop('checked', true); 
        $feedback.text('');
        if (allSelectedBlockStarts[dayNum]) {
            delete allSelectedBlockStarts[dayNum];
            $('.datepicker').datepicker('refresh'); 
        }
        return;
    }

    // 2. Handle the "filled" case (VALIDATION)
    const userAssignedShift = window.USER_INFO ? window.USER_INFO.shift : null;
    let dateForCalc;
    let validationError = "";

    try {
        // --- VALIDATION CHECKS (Format, Validity, Range, Shift) ---
        const dateParts = dateText.split('/');
        if (dateParts.length !== 3 || dateParts[2].length !== 4) {
             throw new Error("Invalid format.");
        }
        
        dateForCalc = new Date(dateParts[2], dateParts[0] - 1, dateParts[1]);
        if (isNaN(dateForCalc.getTime())) {
            throw new Error("Invalid date entered.");
        }

        const { shift: selectedShift, blockStartDate, block } = getShiftAndBlock(dateForCalc);
        
        if (selectedShift === "Pre-Cycle") {
            throw new Error("Date is before cycle start.");
        }

        if (selectedShift !== userAssignedShift) {
            throw new Error(`Shift mismatch (${selectedShift}).`);
        }
        
        // --- 3. VALID STATE ACTIONS ---
        const formattedDate = formatDate(blockStartDate);
        $input.val(formattedDate).addClass('border-green-500'); // ✅ Green border on success
        
        // Update global state
        allSelectedBlockStarts[dayNum] = blockStartDate;
        
        // Update feedback
        $feedback.text(`Block ${block}`).addClass('bg-blue-200 text-blue-800 border-blue-400'); // Example coloring
        $shiftCheckboxes.prop('disabled', false); 
        $('.datepicker').datepicker('refresh'); 

    } catch (e) {
        // --- 4. INVALID STATE ACTIONS (Error Highlighting) ---
        validationError = e.message;
        
        // Apply Red Styling
        $input.addClass('border-red-500'); // ❌ Red border on failure
        $feedback.text(validationError).addClass('bg-red-200 text-red-800 border-red-400');
        
        // Clear the bad data
        $input.val("");
        
        // Reset state
        $shiftCheckboxes.prop('disabled', true).prop('checked', false); // Disable checkboxes on error
        if (allSelectedBlockStarts[dayNum]) {
            delete allSelectedBlockStarts[dayNum];
            $('.datepicker').datepicker('refresh'); 
        }
    }
}

/**
 * Fills data into a specific date block and ensures the global state is updated.
 * This is called by fillPreviousPicks.
 * @param {string} dateText - The RAW date string (e.g., "Fri Feb 06 2026...").
 * @param {string} shiftsString - Comma-separated shifts (e.g., "Day1, Day2").
 * @param {number} dayIndex - The day number (1, 2, 3...)
 */
function loadPickIntoDayBlock(dateText, shiftsString, dayIndex) {
    const $dateInput = $(`#day${dayIndex}-date`);
    
    // --- FIX A: PARSE AND FORMAT THE DATE ---
    let blockStartDate;
    let formattedDate;
    try {
        // 1. Create a Date object from the raw string
        blockStartDate = new Date(dateText);
        
        // 2. Format it to MM/DD/YYYY
        // We'll add a simple formatter here to be safe
        let month = (blockStartDate.getMonth() + 1).toString().padStart(2, '0');
        let day = blockStartDate.getDate().toString().padStart(2, '0');
        let year = blockStartDate.getFullYear();
        formattedDate = `${month}/${day}/${year}`;

    } catch (e) {
        console.error(`Could not parse date ${dateText} for day ${dayIndex}.`, e);
        $dateInput.val("INVALID DATE"); // Show an error
        return; // Stop
    }
    // ------------------------------------

    // 1. Set the *formatted* date value in the input field
    $dateInput.val(formattedDate);

    // 2. Set the global selection state (using the Date object)
    allSelectedBlockStarts[dayIndex] = blockStartDate;
    
    // 3. Set checkboxes (This will run now that the date parsing is fixed)
    const shiftsArray = shiftsString.split(',').map(s => s.trim());
    
    $(`input[name="day${dayIndex}Shift"]`).prop('checked', false);
    shiftsArray.forEach(shiftValue => {
        $(`input[name="day${dayIndex}Shift"][value="${shiftValue}"]`).prop('checked', true);
    });

    // 4. Force enforcement/feedback update
    enforceCheckboxState($dateInput, dayIndex);
}

function fillPreviousPicks(picksRow) {
    
    // --- SET ACKNOWLEDGMENT (Existing logic remains) ---
    var acknowledgment = picksRow[7]; 
    if (acknowledgment) {
        $(`input[name="formCompletion"][value="${acknowledgment}"]`).prop('checked', true);
        $('input[name="formCompletion"]').trigger('change');
    }
    // -----------------------------------------------------------
    
    var START_PICK_INDEX = 9; // Index of Day 1 column (Column J)
    var pickCount = 0;

    // We iterate through the picksRow, jumping 2 columns at a time.
    for (var i = START_PICK_INDEX; i < picksRow.length; i += 2) {
        var dateText = picksRow[i]; // This is the RAW date string
        var shiftString = picksRow[i + 1]; // e.g., "Day1, Day2"
        
        // Stop if the date column is empty
        if (!dateText) break;

        pickCount++;
        
        // Check to ensure we don't exceed the max (safety)
        if (pickCount > MAX_DAYS) break; 
        
        // A. Handle Day 1 (which is already in the DOM)
        if (pickCount === 1) {
            loadPickIntoDayBlock(dateText, shiftString, 1);
        } else {
            // B. Handle Day 2 and subsequent days:
            // The Day 1 block is already visible, but Day 2/3/etc. slots MUST be created.
            addNewDayBlock(); // Creates the slot for pickCount=2, 3, 4, etc.
            
            // loadPickIntoDayBlock uses currentDayCount, which was just incremented by addNewDayBlock
            loadPickIntoDayBlock(dateText, shiftString, currentDayCount);
        }
    }
    
    // --- CRITICAL FIX: Add ONLY the single blank day after the loop ends ---
    // This is the clean, single slot the user needs to interact with next.
    // It runs regardless of whether pickCount is 1 or 5, ensuring a single blank line.
    if (currentDayCount < MAX_DAYS) {
        addNewDayBlock(); 
    }
    // ------------------------------------------------------------------
    
    // CRITICAL: Refresh all datepickers to show the correct global highlights
    $('.datepicker').datepicker('refresh'); 
}

/**
 * Removes all redundant empty day selection blocks, leaving only the first blank spot.
 * This also ensures there is *always* at least one empty block available,
 * provided MAX_DAYS hasn't been reached.
 */
function collapseEmptyRows() {
    const $allBlocks = $('#day-selection-container').find('.day-selection-block');
    
    // We use a flag to track the first time we encounter an empty block.
    let foundFirstEmpty = false;
    let blocksToDelete = $(); // Initialize an empty jQuery collection
    
    $allBlocks.each(function() {
        const $block = $(this);
        const isEmpty = $block.find('input[id$="-date"]').val().length === 0;

        if (isEmpty) {
            if (foundFirstEmpty) {
                // This is the second, third, etc., empty block. Mark for deletion.
                blocksToDelete = blocksToDelete.add($block);
            } else {
                // This is the first empty block. We KEEP this one and set the flag.
                foundFirstEmpty = true;
            }
        }
    });

    // 1. Perform the deletion animation and DOM removal
    blocksToDelete.fadeOut(200, function() {
        $(this).remove();
    });

    // 2. Recalculate the global counter based on the DOM length
    // We wait 250ms to ensure the deletion animation finishes before recalculating the true count.
    setTimeout(function() {
        // Recalculate the current number of rows in the DOM
        currentDayCount = $('#day-selection-container').find('.day-selection-block').length;
        
        // --- NEW LOGIC: Add a new block if one is needed ---
        // If we didn't find *any* empty block, it means all existing blocks are filled.
        // In this case, we need to add the next blank row (if max not reached).
        if (!foundFirstEmpty && currentDayCount < MAX_DAYS) {
            addNewDayBlock();
        }
    }, 250); 
}

    /**
     * This is the main function called from Form_Refactored.html
     */
    function initializeDatepicker() {
        applyComplexDatepicker('#day1-date');
    }
</script>
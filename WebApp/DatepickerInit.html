<script>
    // Global variables initialized in DatepickerInit
    let currentDayCount = 0;
    console.log("Current Day Initialized at ", currentDayCount);
    const MAX_DAYS = 30;
    defaultStartDate = new Date('2026-02-04')
    endSelectDate = new Date('2027-01-01')
    // Global list to track all selected block start dates
    let allSelectedBlockStarts = {};

    // Track which input is currently opening the datepicker
    let currentOpenInputId = null;


    /**
     * Generates the HTML string for a new day selection block.
     * NOTE: We remove the 'disabled' check from the template since it's now handled
     * dynamically in onSelect whenever a date is picked.
     */
    function createDayBlock(dayNum) {
        console.log("Creating Day HTML");
        return `
    <div id="day-${dayNum}-selection" class="flex flex-col rounded-lg sm:flex-row gap-4 sm:gap-8 items-start sm:items-center py-3 px-3 border-t mt-2 day-selection-block bg-white/80 shadow-sm transition-shadow duration-200" style="display: none;">
        
        <div class="drag-handle cursor-move p-1 flex-shrink-0">
            <svg class="w-3 h-3 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
                <path d="M7 2a2 2 0 1 1-4 0 2 2 0 0 1 4 0zM7 8a2 2 0 1 1-4 0 2 2 0 0 1 4 0zM7 14a2 2 0 1 1-4 0 2 2 0 0 1 4 0zM17 2a2 2 0 1 1-4 0 2 2 0 0 1 4 0zM17 8a2 2 0 1 1-4 0 2 2 0 0 1 4 0zM17 14a2 2 0 1 1-4 0 2 2 0 0 1 4 0z"/>
            </svg>
        </div>
        
        <div class="flex-1 min-w-0 sm:w-64"> 
            <label for="day${dayNum}-date" class="block text-base font-medium text-gray-700 mb-1">Date</label>
            <input type="text" id="day${dayNum}-date" name="day${dayNum}Date" 
                   class="datepicker w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500" 
                   placeholder="MM/DD/YYYY" autocomplete="off">
            
            <div class="mt-1 h-6">
                <span id="day${dayNum}-shift-feedback" class="text-xs text-gray-500 px-2 py-1 rounded-full font-semibold border border-transparent transition-all duration-300 whitespace-nowrap">
                    MM-DD-YYYY (Click input)
                </span>
            </div>

            <div id="warning-${dayNum}" class="hidden mt-2 p-2 bg-yellow-50 rounded border border-yellow-200 flex items-start w-full sm:w-auto">
                <svg class="h-4 w-4 text-yellow-600 mr-2 mt-0.5 shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                </svg>
                <p class="text-xs text-yellow-700 leading-snug">
                    <strong>Half-Tour:</strong> You are only requesting off one day.
                </p>
            </div>
        </div>

        <div class="shrink-0 max-w-xs"> 
            <label class="block text-base font-medium text-gray-700 mb-1">Shift Selection ${dayNum}</label>
            <div class="flex flex-col space-y-2">
                
                <div class="flex items-center">
                    <input id="day${dayNum}-shift-day1" name="day${dayNum}Shift" type="checkbox" value="Day1" checked 
                           onchange="toggleHalfTourWarning(${dayNum})"
                           class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                    <label for="day${dayNum}-shift-day1" class="ml-2 text-sm font-medium text-gray-700">Day 1</label>
                </div>

                <div class="flex items-center">
                    <input id="day${dayNum}-shift-day2" name="day${dayNum}Shift" type="checkbox" value="Day2" checked 
                           onchange="toggleHalfTourWarning(${dayNum})"
                           class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                    <label for="day${dayNum}-shift-day2" class="ml-2 text-sm font-medium text-gray-700">Day 2</label>
                </div>

                <div class="mt-2 pt-2 border-t border-gray-100 flex items-center">
                    <input id="day${dayNum}-prioritize" name="day${dayNum}Prioritize" type="checkbox" value="yes" disabled 
                           class="h-4 w-4 text-orange-500 border-gray-300 rounded focus:ring-orange-400">
                    <label for="day${dayNum}-prioritize" class="ml-2 text-xs italic text-gray-500">Prioritize Later Day First</label>
                </div>
            </div>
        </div>
    </div>
    `;
    }

    /**
     * This function contains your complex datepicker configuration.
     */
    function applyComplexDatepicker(inputElement) {

        $(inputElement).datepicker({
            dateFormat: 'mm/dd/yy',
            defaultDate: defaultStartDate,
            maxDate: endSelectDate,

            // Your hover logic (unchanged)
            beforeShow: function (input, inst) {
                // Track which input is currently open
                currentOpenInputId = this.id;
                console.log("Opened datepicker for:", currentOpenInputId, "with value:", this.value);

                setTimeout(function () {
                    $('.ui-datepicker-calendar a').off('mouseenter mouseleave')
                        .on('mouseenter', function () {
                            const tdElement = $(this).closest('td');
                            const dayNum = parseInt($(this).text(), 10);
                            const linkMonth = parseInt(tdElement.attr('data-month'), 10);
                            const linkYear = parseInt(tdElement.attr('data-year'), 10);
                            if (isNaN(dayNum) || isNaN(linkMonth) || isNaN(linkYear)) return;
                            const linkDate = new Date(linkYear, linkMonth, dayNum);
                            const { blockStartDate } = getShiftAndBlock(linkDate);
                            toggleBlockHover(blockStartDate, 'add');
                        })
                        .on('mouseleave', function () {
                            const tdElement = $(this).closest('td');
                            const dayNum = parseInt($(this).text(), 10);
                            const linkMonth = parseInt(tdElement.attr('data-month'), 10);
                            const linkYear = parseInt(tdElement.attr('data-year'), 10);
                            if (isNaN(dayNum) || isNaN(linkMonth) || isNaN(linkYear)) return;
                            const linkDate = new Date(linkYear, linkMonth, dayNum);
                            const { blockStartDate } = getShiftAndBlock(linkDate);
                            toggleBlockHover(blockStartDate, 'remove');
                        });
                }, 0);
            },

            // --- onSelect (Modified for Checkbox Disabling) ---
            onSelect: function (dateText, inst) {
                console.log("Datepicker Select Function Called")
                const selectedDate = new Date(inst.selectedYear, inst.selectedMonth, inst.selectedDay);
                const { blockStartDate, shift } = getShiftAndBlock(selectedDate);
                const $input = $(this);
                const dayNum = parseInt(this.id.match(/^day(\d+)-date$/)[1]);

                if (blockStartDate) {
                    allSelectedBlockStarts[dayNum] = blockStartDate;
                    const formattedDate = formatDate(blockStartDate);
                    $input.val(formattedDate);

                    // Refresh ALL datepickers to show the new global state
                    $('.datepicker').datepicker('refresh');

                    // Update feedback
                    const $feedback = $(`#day${dayNum}-shift-feedback`);
                    const { block } = getShiftAndBlock(blockStartDate);
                }

                // Do NOT call any empty row management here - let the change handler do it
                $input.trigger('change');
            },

            // --- beforeShowDay (Modified for Calendar Day Disabling) ---
            beforeShowDay: function (date) {
                const { class: shiftClass, blockStartDate, shift: currentShift } = getShiftAndBlock(date);
                let extraClass = shiftClass;

                const userAssignedShift = window.USER_INFO ? window.USER_INFO.shift : null;
                let isSelectable = true;
                let isGloballyBooked = false;

                // Get the current input's ID and day number from our tracked variable
                const currentInputId = currentOpenInputId;
                const currentDayNumMatch = currentInputId ? currentInputId.match(/^day(\d+)-date$/) : null;
                const currentDayNum = currentDayNumMatch ? parseInt(currentDayNumMatch[1]) : null;

                // Get the current input's selected date value
                const currentInputValue = currentInputId ? $(`#${currentInputId}`).val() : '';

                // Safety check for shift restriction
                if (!currentInputId) {
                    // Datepicker not fully initialized yet
                    if (userAssignedShift && currentShift && currentShift !== userAssignedShift) {
                        return [false, shiftClass, `Shift ${currentShift}`];
                    }
                    return [true, shiftClass, `Shift ${currentShift}`];
                }

                // 1. SHIFT RESTRICTION CHECK: Disable days that don't match the user's shift
                if (userAssignedShift && currentShift && currentShift !== userAssignedShift) {
                    isSelectable = false;
                }


                // 2. GLOBAL BOOKING CHECK & HIGHLIGHT LOGIC
                const currentDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());

                for (const dayKey in allSelectedBlockStarts) {
                    const selectedBlockStartDate = allSelectedBlockStarts[dayKey];
                    if (!selectedBlockStartDate) continue;

                    // --- KEY MODIFICATION: Skip checking the dates selected by the current input ---
                    if (parseInt(dayKey) === currentDayNum) {
                        continue;
                    }

                    // Calculate the two days of the globally selected block
                    const selectedDay1 = new Date(selectedBlockStartDate.getFullYear(), selectedBlockStartDate.getMonth(), selectedBlockStartDate.getDate());
                    const selectedDay2 = new Date(selectedDay1);
                    selectedDay2.setDate(selectedDay2.getDate() + 1);

                    // Check if the current calendar day matches any OTHER selected block
                    const isDay1Match = currentDate.getTime() === selectedDay1.getTime();
                    const isDay2Match = currentDate.getTime() === selectedDay2.getTime();

                    if (isDay1Match || isDay2Match) {
                        isGloballyBooked = true;
                        extraClass += ' ui-state-highlight ui-state-active selected-shift-day globally-booked-disabled';
                        break;
                    }
                }

                // 3. ENFORCEMENT: If the day is part of an already selected block (by a *different* input), make it UNSELECTABLE
                if (isGloballyBooked) {
                    isSelectable = false;
                }


                // 4. BLOCK STYLING (Unchanged)
                if (blockStartDate) {
                    const secondDay = new Date(blockStartDate.getFullYear(), blockStartDate.getMonth(), blockStartDate.getDate());
                    secondDay.setDate(secondDay.getDate() + 1);
                    const isBlockStart = currentDate.getTime() === blockStartDate.getTime();
                    const isBlockSecondDay = currentDate.getTime() === secondDay.getTime();
                    const firstDayIsWeekend = blockStartDate.getDay() === 0 || blockStartDate.getDay() === 6;
                    const secondDayIsWeekend = secondDay.getDay() === 0 || secondDay.getDay() === 6;
                    const bothDaysWeekend = firstDayIsWeekend && secondDayIsWeekend;

                    if (isBlockStart) { extraClass += ' shift-block-start'; if (bothDaysWeekend) extraClass += ' both-days-weekend'; }
                    if (isBlockSecondDay) { extraClass += ' shift-block-end'; if (bothDaysWeekend) extraClass += ' both-days-weekend'; }
                }

                // 5. CURRENT INPUT'S SELECTION (Your logic, fixed)
                // 'date' is the calendar day. 'currentSelectionDate' is the specific day from the calendar
                const currentSelectionDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());

                // Get the date string from your global variable
                const myGlobalDateString = window.selectedDate;

                if (myGlobalDateString) { // Check if it's not ""
                    try {
                        // Create a Date object from the global string (e.g., "02/12/2026")
                        const dateParts = myGlobalDateString.split('/');
                        const mySelectedBlock = new Date(dateParts[2], dateParts[0] - 1, dateParts[1]);

                        // Calculate the two days of the block
                        const selectedDay1 = new Date(mySelectedBlock.getFullYear(), mySelectedBlock.getMonth(), mySelectedBlock.getDate());
                        const selectedDay2 = new Date(selectedDay1);
                        selectedDay2.setDate(selectedDay2.getDate() + 1);

                        // --- THIS IS THE FIX ---
                        // Compare the CALENDAR DAY (currentDate) to the GLOBAL block
                        const isDay1Match = currentDate.getTime() === selectedDay1.getTime();
                        const isDay2Match = currentDate.getTime() === selectedDay2.getTime();

                        if (isDay1Match || isDay2Match) {
                            // It's a match, so highlight and "unlock" it
                            extraClass += ' ui-state-highlight ui-state-active selected-shift-day ui-datepicker-current-day';
                            extraClass = extraClass.replace('globally-booked-disabled', '');
                            isSelectable = true; // Override any previous 'false'
                        }
                    } catch (e) {
                        // This will catch "Invalid Date" errors if the string is bad
                    }
                }

                // Return [isSelectable, extraClass, title]
                return [isSelectable, extraClass, `Shift ${currentShift}`];
            }
        });

        // Handle clearing an input - simplified to ONLY do validation
        $(inputElement).on('change', function () {
            console.log("Selected a value through datepickerInit!");
            const $input = $(this);
            const dayNum = parseInt(this.id.match(/^day(\d+)-date$/)[1]);

            // The core validation now runs here
            enforceCheckboxState($input, dayNum);

            // NEW: always run empty-row logic after a valid change
            clearTimeout(window.emptyRowTimeout);
            window.emptyRowTimeout = setTimeout(manageEmptyRows, 50);
        });
    }

    /**
     * Handles creating the new block, initializing its datepicker, and showing it.
     */
    function addNewDayBlock() {
        currentDayCount++;
        const newBlockHtml = createDayBlock(currentDayCount);
        const $newBlock = $(newBlockHtml);
        $('#day-selection-container').append($newBlock);

        const newInput = $newBlock.find('.datepicker');
        applyComplexDatepicker(newInput);

        $newBlock.slideDown(200, function () {
            $('#day-selection-container').sortable('refresh');
        });
    }

    function enforceCheckboxState($input, dayNum) {
        console.log("Validating status");
        const dateText = $input.val();
        const $shiftCheckboxes = $(`input[name="day${dayNum}Shift"]`);
        // --- NEW SELECTOR ---
        const $prioritizeCheckbox = $(`#day${dayNum}-prioritize`);
        // --------------------
        const $feedback = $(`#day${dayNum}-shift-feedback`);

        // reset styles
        $input.removeClass('border-red-500 border-green-500');
        $feedback.removeClass(
            'bg-red-200 bg-blue-200 bg-orange-200 text-red-800 text-blue-800 text-orange-800 border-red-400 border-blue-400 border-orange-400 border'
        );

        // EMPTY = user intentionally cleared date
        const checkedShifts = $shiftCheckboxes.filter(':checked').length;
        const shouldClear = !dateText || (dateText && checkedShifts === 0);

        if (shouldClear) {
            $input.val("");

            // Reset Shifts
            $shiftCheckboxes.prop('disabled', false).prop('checked', false);

            // --- NEW: Reset Prioritize Checkbox ---
            $prioritizeCheckbox.prop('checked', false).prop('disabled', true);
            // -------------------------------------

            $feedback.text('');
            if (allSelectedBlockStarts[dayNum]) {
                delete allSelectedBlockStarts[dayNum];
                $('.datepicker').datepicker('refresh');
            }

            $(`label[for="day${dayNum}-shift-day1"]`).text('Day 1');
            $(`label[for="day${dayNum}-shift-day2"]`).text('Day 2');
            return;
        }

        // 2. Handle the "filled" case (VALIDATION)
        const userAssignedShift = window.USER_INFO ? window.USER_INFO.shift : null;
        let dateForCalc;
        let validationError = "";

        try {
            // ... [Validation checks remain the same] ...
            const dateParts = dateText.split('/');
            if (dateParts.length !== 3 || dateParts[2].length !== 4) {
                throw new Error("Invalid format (MM/DD/YYYY).");
            }

            dateForCalc = new Date(dateParts[2], dateParts[0] - 1, dateParts[1]);
            if (isNaN(dateForCalc.getTime())) {
                throw new Error("Invalid date entered.");
            }

            const { shift: selectedShift, blockStartDate } = getShiftAndBlock(dateForCalc);

            if (selectedShift === "Pre-Cycle") {
                throw new Error("Date is before cycle start.");
            }

            if (userAssignedShift && selectedShift !== userAssignedShift) {
                throw new Error(
                    `This date is on Shift ${selectedShift}. Your shift is ${userAssignedShift}.`
                );
            }

            // âœ… VALID
            const formattedDate = formatDate(blockStartDate);
            $input.data('invalid', false);
            $input.val(formattedDate).addClass('border-green-500');

            // Update global state
            allSelectedBlockStarts[dayNum] = blockStartDate;

            const day2Date = new Date(blockStartDate);
            day2Date.setDate(day2Date.getDate() + 1);
            const day1Formatted = formatDate(blockStartDate);
            const day2Formatted = formatDate(day2Date);

            // Update Day 1 Label
            $(`label[for="day${dayNum}-shift-day1"]`).text(day1Formatted);
            // Update Day 2 Label
            $(`label[for="day${dayNum}-shift-day2"]`).text(day2Formatted);
            // ------------------------------------


            $feedback
                .text(`Shift ${selectedShift} â€“ OK`)
                .addClass('bg-blue-200 text-blue-800 border-blue-400');

            $shiftCheckboxes.prop('disabled', false);

            // --- NEW: Enable Prioritize Checkbox ---
            $prioritizeCheckbox.prop('disabled', false);
            // ---------------------------------------

            $('.datepicker').datepicker('refresh');

        } catch (e) {
            // âŒ INVALID â€“ keep the value so row is NOT treated as empty
            $input.data('invalid', true); // âŒ Set invalid flag to true
            validationError = e.message;

            $input.addClass('border-red-500');
            $feedback
                .text(validationError)
                .addClass('bg-red-200 text-red-800 border-red-400');

            // do NOT clear value, do NOT mark block as empty
            // (optional) keep shifts enabled so the row feels editable
            $shiftCheckboxes.prop('disabled', false);

            // --- NEW: Reset Prioritize Checkbox on error ---
            $prioritizeCheckbox.prop('disabled', true).prop('checked', false);
            // ----------------------------------------------

            $(`label[for="day${dayNum}-shift-day1"]`).text('Day 1');
            $(`label[for="day${dayNum}-shift-day2"]`).text('Day 2');
        }
    }

    /**
     * Fills data into a specific date block and ensures the global state is updated.
     * This is called by fillPreviousPicks.
     * @param {string} dateText - The RAW date string (e.g., "Fri Feb 06 2026...").
     * @param {string} shiftsString - Comma-separated shifts (e.g., "Day1, Day2").
     * @param {number} dayIndex - The day number (1, 2, 3...)
     */
    function loadPickIntoDayBlock(dateText, shiftsString, dayIndex, prioritizeLater = false) {
        const $dateInput = $(`#day${dayIndex}-date`);

        // --- FIX A: PARSE AND FORMAT THE DATE ---
        let blockStartDate;
        let formattedDate;
        try {
            // 1. Create a Date object from the raw string
            blockStartDate = new Date(dateText);

            // 2. Format it to MM/DD/YYYY
            // We'll add a simple formatter here to be safe
            let month = (blockStartDate.getMonth() + 1).toString().padStart(2, '0');
            let day = blockStartDate.getDate().toString().padStart(2, '0');
            let year = blockStartDate.getFullYear();
            formattedDate = `${month}/${day}/${year}`;

        } catch (e) {
            console.error(`Could not parse date ${dateText} for day ${dayIndex}.`, e);
            $dateInput.val("INVALID DATE"); // Show an error
            return; // Stop
        }
        // ------------------------------------

        // 1. Set the *formatted* date value in the input field
        $dateInput.val(formattedDate);

        // 2. Set the global selection state (using the Date object)
        allSelectedBlockStarts[dayIndex] = blockStartDate;

        // 3. Set checkboxes (This will run now that the date parsing is fixed)
        const shiftsArray = shiftsString.split(',').map(s => s.trim());

        $(`input[name="day${dayIndex}Shift"]`).prop('checked', false);
        shiftsArray.forEach(shiftValue => {
            $(`input[name="day${dayIndex}Shift"][value="${shiftValue}"]`).prop('checked', true);
        });

        toggleHalfTourWarning(dayIndex);

        // --- NEW: Set Prioritize Checkbox ---
        if (prioritizeLater) {
            $(`#day${dayIndex}-prioritize`).prop('checked', true);
        }
        // ------------------------------------

        // 4. Force enforcement/feedback update
        enforceCheckboxState($dateInput, dayIndex);
    }


    function fillPreviousPicks(picksRow) {

        // --- SET ACKNOWLEDGMENT (Existing logic remains) ---
        var acknowledgment = picksRow[7];
        if (acknowledgment) {
            $(`input[name="formCompletion"][value="${acknowledgment}"]`).prop('checked', true);
            $('input[name="formCompletion"]').trigger('change');
        }
        // -----------------------------------------------------------

        var START_PICK_INDEX = 9; // Index of Day 1 column (Column J)
        var pickCount = 0;

        // We iterate through the picksRow, jumping 2 columns at a time.
        for (var i = START_PICK_INDEX; i < picksRow.length; i += 2) {
            var dateText = picksRow[i]; // This is the RAW date string
            var shiftString = picksRow[i + 1]; // e.g., "Day1, Day2"

            // Stop if the date column is empty
            if (!dateText) break;

            pickCount++;

            // Check to ensure we don't exceed the max (safety)
            if (pickCount > MAX_DAYS) break;

            // A. Handle Day 1 (which is already in the DOM)
            if (pickCount === 1) {
                loadPickIntoDayBlock(dateText, shiftString, 1);
            } else {
                // B. Handle Day 2 and subsequent days:
                // The Day 1 block is already visible, but Day 2/3/etc. slots MUST be created.
                addNewDayBlock(); // Creates the slot for pickCount=2, 3, 4, etc.

                // loadPickIntoDayBlock uses currentDayCount, which was just incremented by addNewDayBlock
                loadPickIntoDayBlock(dateText, shiftString, currentDayCount);
            }
        }

        // --- CRITICAL FIX: Add ONLY the single blank day after the loop ends ---
        // This is the clean, single slot the user needs to interact with next.
        // It runs regardless of whether pickCount is 1 or 5, ensuring a single blank line.
        if (currentDayCount < MAX_DAYS) {
            addNewDayBlock();
        }
        // ------------------------------------------------------------------

        // CRITICAL: Refresh all datepickers to show the correct global highlights
        $('.datepicker').datepicker('refresh');
    }






    // SINGLE CHANGE HANDLER - manages all empty row logic
    $('#day-selection-container').off('change').on('change', 'input', function () {
        console.log("Detected change through formLogic!");
        // Debounce to prevent multiple rapid calls
        clearTimeout(window.emptyRowTimeout);
        window.emptyRowTimeout = setTimeout(manageEmptyRows, 50);
    });

    // Robust empty row management function
    function manageEmptyRows() {
        console.log("Running ManageEmptyRows()")
        const $container = $('#day-selection-container');
        const $allBlocks = $container.find('.day-selection-block');

        let emptyBlocks = [];
        let filledBlocks = [];

        // Categorize all blocks
        $allBlocks.each(function () {
            const $block = $(this);
            const $dateInput = $block.find('input[id$="-date"]');
            const hasDate = $dateInput.val().trim() !== '';
            const hasCheckedShifts = $block.find('input[type="checkbox"]:checked').length > 0;
            console.log({ date: $dateInput.val().trim(), checked: $block.find('input[type="checkbox"]:checked').length > 0 })
            if (!hasDate) {
                emptyBlocks.push($block);
            } else {
                filledBlocks.push($block);
            }
        });

        console.log(`Found ${emptyBlocks.length} empty blocks, ${filledBlocks.length} filled blocks`);

        // Remove excess empty blocks (keep only the first one)
        if (emptyBlocks.length > 1) {
            for (let i = 1; i < emptyBlocks.length; i++) {
                console.log(`Removing excess empty block ${i}`);
                emptyBlocks[i].remove();
            }
            emptyBlocks = [emptyBlocks[0]]; // Keep only the first
        }

        // If no empty blocks exist and we haven't reached max, add one
        if (emptyBlocks.length === 0 && $allBlocks.length < MAX_DAYS) {
            console.log('No empty blocks found, adding one');
            addNewDayBlock();
        }

        // Reorder indices after any changes
        reorderDayIndices();
    }

    // Reorder day indices after sorting
    function reorderDayIndices() {
        console.log("reorderDayIndicies");

        const newAllSelectedBlockStarts = {};

        $('#day-selection-container .day-selection-block').each(function (index) {
            const newIndex = index + 1;
            const $block = $(this);

            // 1. Store the old date value before changing IDs
            const $dateInput = $block.find('input[id$="-date"]');
            const dateValue = $dateInput.val();

            // Update block ID
            $block.attr('id', `day-${newIndex}-selection`);

            // Update all IDs and names in the block
            $block.find('input, label, span').each(function () {
                const $el = $(this);
                const oldId = $el.attr('id');
                const oldName = $el.attr('name');
                const oldFor = $el.attr('for');

                if (oldId) {
                    // Use a regex that replaces the last number sequence, regardless of size
                    $el.attr('id', oldId.replace(/day\d+/, `day${newIndex}`));
                }
                if (oldName) {
                    $el.attr('name', oldName.replace(/day\d+/, `day${newIndex}`));
                }
                if (oldFor) {
                    $el.attr('for', oldFor.replace(/day\d+/, `day${newIndex}`));
                }
            });

            // Update shift selection labels
            $block.find('label:contains("Shift Selection")').text(`Shift Selection ${newIndex}`);

            // 2. Reconstruct new allSelectedBlockStarts map based on the dateValue
            if (dateValue) {
                try {
                    // Safely parse the MM/DD/YYYY string back into a Date object
                    const dateParts = dateValue.split('/');
                    const parsedDate = new Date(dateParts[2], dateParts[0] - 1, dateParts[1]);

                    if (!isNaN(parsedDate.getTime())) {
                        newAllSelectedBlockStarts[newIndex] = parsedDate;
                    }
                } catch (e) {
                    console.error(`Re-indexing failed to parse date for new index ${newIndex}:`, dateValue, e);
                }
            }
        });

        // 3. Update global state variables
        currentDayCount = $('#day-selection-container .day-selection-block').length;
        console.log("reorderDayIndices set day count to: ", currentDayCount);
        allSelectedBlockStarts = newAllSelectedBlockStarts;

        // 4. ðŸ”¥ CRITICAL FIX: Destroy and Re-apply Datepicker
        // This is necessary because changing the ID of an input element requires 
        // the jQuery UI Datepicker instance to be fully reset and re-initialized 
        // so it can register the new ID and metadata.
        $('.datepicker').each(function () {
            const $input = $(this);

            // Destroy the old instance if it exists
            if ($input.data('datepicker')) {
                $input.datepicker('destroy');
            }

            // Re-apply the complex datepicker (which includes the 'change' handler binding)
            applyComplexDatepicker(this);
        });
    }

    function toggleHalfTourWarning(dayNum) {
        const checkbox1 = document.getElementById(`day${dayNum}-shift-day1`);
        const checkbox2 = document.getElementById(`day${dayNum}-shift-day2`);
        const warningDiv = document.getElementById(`warning-${dayNum}`);

        if (!checkbox1 || !checkbox2 || !warningDiv) return;

        // Check count: 1 = Half Tour, 2 = Full Tour, 0 = Empty
        const count = (checkbox1.checked ? 1 : 0) + (checkbox2.checked ? 1 : 0);

        if (count === 1) {
            warningDiv.classList.remove('hidden');
        } else {
            warningDiv.classList.add('hidden');
        }
    }

    /**
     * This is the main function called from Form_Refactored.html
     */
    function initializeDatepicker() {
        // init sortable for future blocks
        $('#day-selection-container').sortable({
            handle: '.drag-handle',
            axis: 'y',
            containment: 'parent',
            tolerance: 'pointer',
            items: '.day-selection-block',
            update: reorderDayIndices
        });

        // (your delegated change handler for manageEmptyRows can stay as-is)

        // bootstrap Day 1 dynamically
        addNewDayBlock();   // creates #day1-selection + #day1-date and wires datepicker
    }

</script>
<script>
    // Global variables initialized in DatepickerInit
    let currentDayCount = 0;
    console.log("Current Day Initialized at ", currentDayCount);
    const MAX_DAYS = 30;
    defaultStartDate = new Date('2026-02-04')
    endSelectDate = new Date('2027-01-01')
    // Global list to track all selected block start dates
    let allSelectedBlockStarts = {};

    // Track which input is currently opening the datepicker
    let currentOpenInputId = null;


    /**
     * Generates the HTML string for a new day selection block.
     * NOTE: We remove the 'disabled' check from the template since it's now handled
     * dynamically in onSelect whenever a date is picked.
     */
    function createDayBlock(dayNum) {
        return `
        <div id="day-${dayNum}-selection" class="flex flex-row border-t mt-4 rounded-lg day-selection-block bg-white shadow-sm overflow-hidden transition-shadow duration-200 group" style="display: none;">
            
            <div class="drag-handle cursor-move w-12 flex-shrink-0 bg-gray-50 hover:bg-gray-100 border-r border-gray-200 flex flex-col items-center justify-center self-stretch" style="touch-action: none;">
                <svg class="w-6 h-6 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
                    <path d="M7 2a2 2 0 1 1-4 0 2 2 0 0 1 4 0zM7 8a2 2 0 1 1-4 0 2 2 0 0 1 4 0zM7 14a2 2 0 1 1-4 0 2 2 0 0 1 4 0zM17 2a2 2 0 1 1-4 0 2 2 0 0 1 4 0zM17 8a2 2 0 1 1-4 0 2 2 0 0 1 4 0zM17 14a2 2 0 1 1-4 0 2 2 0 0 1 4 0z"/>
                </svg>
            </div>
            
            <div class="flex-1 flex flex-col sm:flex-row gap-2 sm:gap-8 items-start sm:items-center p-3 sm:p-4 min-w-0 relative">
                
                <div class="flex-1 w-full sm:w-64 min-w-0"> 
                    <label for="day${dayNum}-date" class="block text-base font-medium text-gray-700 mb-1">Date</label>
                    
                    <input type="text" id="day${dayNum}-date" name="day${dayNum}Date" 
                        class="datepicker w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 text-base" 
                        placeholder="MM/DD/YYYY" autocomplete="off">

                    <input type="text" id="day${dayNum}-ghost-date" disabled
                        class="hidden w-full p-2 border border-blue-300 bg-gray-100 text-gray-500 bg-blue-50 rounded-md cursor-not-allowed text-base" 
                        value="">
                    
                    <div class="mt-1 h-6">
                        <span id="day${dayNum}-shift-feedback" class="text-xs text-gray-500 px-2 py-1 rounded-full font-semibold border border-transparent transition-all duration-300 whitespace-nowrap">
                            MM-DD-YYYY (Click input)
                        </span>
                    </div>
                    <div id="warning-${dayNum}" class="hidden mt-2 p-2 bg-yellow-50 rounded border border-yellow-200 flex items-start w-full sm:w-auto">
                        <svg class="h-4 w-4 text-yellow-600 mr-2 mt-0.5 shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                        </svg>
                        <p class="text-xs text-yellow-700 leading-snug">
                            <strong>Half-Tour:</strong> Only 1 day selected.
                        </p>
                    </div>
                </div>

                <div class="shrink-0 max-w-xs w-full sm:w-auto"> 
                    <div class="flex justify-between items-center mb-1">
                        <label class="block text-base font-medium text-gray-700">Shift Selection ${dayNum}</label>
                        <div class="flex space-x-2 ml-2">
                            <button type="button" id="btn-split-${dayNum}" onclick="performSplit(${dayNum})" class="text-gray-400 hover:text-blue-600" title="Split into two separate entries">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.121 14.121L19 19m-7-7l7-7m-7 7l-2.879 2.879M12 12L9.121 9.121m0 5.758a3 3 0 10-4.243 4.243 3 3 0 004.243-4.243zm8.486-8.486a3 3 0 10-4.243 4.243 3 3 0 004.243-4.243z"></path></svg>
                            </button>
                            <button type="button" id="btn-merge-${dayNum}" onclick="performMerge(${dayNum})" class="hidden text-blue-500 hover:text-red-600" title="Merge back into one entry">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path></svg>
                            </button>
                        </div>
                    </div>

                    <div class="flex flex-col space-y-2">
                        <div class="flex items-center">
                            <input id="day${dayNum}-shift-day1" name="day${dayNum}Shift" type="checkbox" value="Day1" checked 
                                onchange="toggleHalfTourWarning(${dayNum})"
                                class="h-5 w-5 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                            <label for="day${dayNum}-shift-day1" class="ml-3 text-sm font-medium text-gray-700">Day 1</label>
                        </div>

                        <div class="flex items-center">
                            <input id="day${dayNum}-shift-day2" name="day${dayNum}Shift" type="checkbox" value="Day2" checked 
                                onchange="toggleHalfTourWarning(${dayNum})"
                                class="h-5 w-5 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                            <label for="day${dayNum}-shift-day2" class="ml-3 text-sm font-medium text-gray-700">Day 2</label>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        `;
    }

    /**
     * This function contains your complex datepicker configuration.
     */
    function applyComplexDatepicker(inputElement) {

        $(inputElement).datepicker({
            dateFormat: 'mm/dd/yy',
            defaultDate: defaultStartDate,
            maxDate: endSelectDate,

            // Your hover logic (unchanged)
            beforeShow: function (input, inst) {
                // Track which input is currently open
                currentOpenInputId = this.id;
                console.log("Opened datepicker for:", currentOpenInputId, "with value:", this.value);

                setTimeout(function () {
                    $('.ui-datepicker-calendar a').off('mouseenter mouseleave')
                        .on('mouseenter', function () {
                            const tdElement = $(this).closest('td');
                            const dayNum = parseInt($(this).text(), 10);
                            const linkMonth = parseInt(tdElement.attr('data-month'), 10);
                            const linkYear = parseInt(tdElement.attr('data-year'), 10);
                            if (isNaN(dayNum) || isNaN(linkMonth) || isNaN(linkYear)) return;
                            const linkDate = new Date(linkYear, linkMonth, dayNum);
                            const { blockStartDate } = getShiftAndBlock(linkDate);
                            toggleBlockHover(blockStartDate, 'add');
                        })
                        .on('mouseleave', function () {
                            const tdElement = $(this).closest('td');
                            const dayNum = parseInt($(this).text(), 10);
                            const linkMonth = parseInt(tdElement.attr('data-month'), 10);
                            const linkYear = parseInt(tdElement.attr('data-year'), 10);
                            if (isNaN(dayNum) || isNaN(linkMonth) || isNaN(linkYear)) return;
                            const linkDate = new Date(linkYear, linkMonth, dayNum);
                            const { blockStartDate } = getShiftAndBlock(linkDate);
                            toggleBlockHover(blockStartDate, 'remove');
                        });
                }, 0);
            },

            // --- onSelect (Modified for Checkbox Disabling) ---
            onSelect: function (dateText, inst) {
                console.log("Datepicker Select Function Called")
                const selectedDate = new Date(inst.selectedYear, inst.selectedMonth, inst.selectedDay);
                const { blockStartDate, shift } = getShiftAndBlock(selectedDate);
                const $input = $(this);
                const dayNum = parseInt(this.id.match(/^day(\d+)-date$/)[1]);

                if (blockStartDate) {
                    allSelectedBlockStarts[dayNum] = blockStartDate;
                    const formattedDate = formatDate(blockStartDate);
                    $input.val(formattedDate);

                    // Refresh ALL datepickers to show the new global state
                    $('.datepicker').datepicker('refresh');

                    // Update feedback
                    const $feedback = $(`#day${dayNum}-shift-feedback`);
                    const { block } = getShiftAndBlock(blockStartDate);
                }

                // Do NOT call any empty row management here - let the change handler do it
                $input.trigger('change');
            },

            // --- beforeShowDay (Modified for Calendar Day Disabling) ---
            beforeShowDay: function (date) {
                const { class: shiftClass, blockStartDate, shift: currentShift } = getShiftAndBlock(date);
                let extraClass = shiftClass;

                const userAssignedShift = window.USER_INFO ? window.USER_INFO.shift : null;
                let isSelectable = true;
                let isGloballyBooked = false;

                // Get the current input's ID and day number from our tracked variable
                const currentInputId = currentOpenInputId;
                const currentDayNumMatch = currentInputId ? currentInputId.match(/^day(\d+)-date$/) : null;
                const currentDayNum = currentDayNumMatch ? parseInt(currentDayNumMatch[1]) : null;

                // Get the current input's selected date value
                const currentInputValue = currentInputId ? $(`#${currentInputId}`).val() : '';

                // Safety check for shift restriction
                if (!currentInputId) {
                    // Datepicker not fully initialized yet
                    if (userAssignedShift && currentShift && currentShift !== userAssignedShift) {
                        return [false, shiftClass, `Shift ${currentShift}`];
                    }
                    return [true, shiftClass, `Shift ${currentShift}`];
                }

                // 1. SHIFT RESTRICTION CHECK: Disable days that don't match the user's shift
                if (userAssignedShift && currentShift && currentShift !== userAssignedShift) {
                    isSelectable = false;
                }


                // 2. GLOBAL BOOKING CHECK & HIGHLIGHT LOGIC
                const currentDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());

                for (const dayKey in allSelectedBlockStarts) {
                    const selectedBlockStartDate = allSelectedBlockStarts[dayKey];
                    if (!selectedBlockStartDate) continue;

                    // --- KEY MODIFICATION: Skip checking the dates selected by the current input ---
                    if (parseInt(dayKey) === currentDayNum) {
                        continue;
                    }

                    // Calculate the two days of the globally selected block
                    const selectedDay1 = new Date(selectedBlockStartDate.getFullYear(), selectedBlockStartDate.getMonth(), selectedBlockStartDate.getDate());
                    const selectedDay2 = new Date(selectedDay1);
                    selectedDay2.setDate(selectedDay2.getDate() + 1);

                    // Check if the current calendar day matches any OTHER selected block
                    const isDay1Match = currentDate.getTime() === selectedDay1.getTime();
                    const isDay2Match = currentDate.getTime() === selectedDay2.getTime();

                    if (isDay1Match || isDay2Match) {
                        isGloballyBooked = true;
                        extraClass += ' ui-state-highlight ui-state-active selected-shift-day globally-booked-disabled';
                        break;
                    }
                }

                // 3. ENFORCEMENT: If the day is part of an already selected block (by a *different* input), make it UNSELECTABLE
                if (isGloballyBooked) {
                    isSelectable = false;
                }


                // 4. BLOCK STYLING (Unchanged)
                if (blockStartDate) {
                    const secondDay = new Date(blockStartDate.getFullYear(), blockStartDate.getMonth(), blockStartDate.getDate());
                    secondDay.setDate(secondDay.getDate() + 1);
                    const isBlockStart = currentDate.getTime() === blockStartDate.getTime();
                    const isBlockSecondDay = currentDate.getTime() === secondDay.getTime();
                    const firstDayIsWeekend = blockStartDate.getDay() === 0 || blockStartDate.getDay() === 6;
                    const secondDayIsWeekend = secondDay.getDay() === 0 || secondDay.getDay() === 6;
                    const bothDaysWeekend = firstDayIsWeekend && secondDayIsWeekend;

                    if (isBlockStart) { extraClass += ' shift-block-start'; if (bothDaysWeekend) extraClass += ' both-days-weekend'; }
                    if (isBlockSecondDay) { extraClass += ' shift-block-end'; if (bothDaysWeekend) extraClass += ' both-days-weekend'; }
                }

                // 5. CURRENT INPUT'S SELECTION (Your logic, fixed)
                // 'date' is the calendar day. 'currentSelectionDate' is the specific day from the calendar
                const currentSelectionDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());

                // Get the date string from your global variable
                const myGlobalDateString = window.selectedDate;

                if (myGlobalDateString) { // Check if it's not ""
                    try {
                        // Create a Date object from the global string (e.g., "02/12/2026")
                        const dateParts = myGlobalDateString.split('/');
                        const mySelectedBlock = new Date(dateParts[2], dateParts[0] - 1, dateParts[1]);

                        // Calculate the two days of the block
                        const selectedDay1 = new Date(mySelectedBlock.getFullYear(), mySelectedBlock.getMonth(), mySelectedBlock.getDate());
                        const selectedDay2 = new Date(selectedDay1);
                        selectedDay2.setDate(selectedDay2.getDate() + 1);

                        // --- THIS IS THE FIX ---
                        // Compare the CALENDAR DAY (currentDate) to the GLOBAL block
                        const isDay1Match = currentDate.getTime() === selectedDay1.getTime();
                        const isDay2Match = currentDate.getTime() === selectedDay2.getTime();

                        if (isDay1Match || isDay2Match) {
                            // It's a match, so highlight and "unlock" it
                            extraClass += ' ui-state-highlight ui-state-active selected-shift-day ui-datepicker-current-day';
                            extraClass = extraClass.replace('globally-booked-disabled', '');
                            isSelectable = true; // Override any previous 'false'
                        }
                    } catch (e) {
                        // This will catch "Invalid Date" errors if the string is bad
                    }
                }

                // Return [isSelectable, extraClass, title]
                return [isSelectable, extraClass, `Shift ${currentShift}`];
            }
        });

        // Handle clearing an input - simplified to ONLY do validation
        $(inputElement).on('change', function () {
            console.log("Selected a value through datepickerInit!");
            const $input = $(this);
            const dayNum = parseInt(this.id.match(/^day(\d+)-date$/)[1]);

            // The core validation now runs here
            enforceCheckboxState($input, dayNum);

            // NEW: always run empty-row logic after a valid change
            clearTimeout(window.emptyRowTimeout);
            window.emptyRowTimeout = setTimeout(manageEmptyRows, 50);
        });
    }

    /**
     * Handles creating the new block, initializing its datepicker, and showing it.
     */
    function addNewDayBlock() {
        currentDayCount++;
        const newBlockHtml = createDayBlock(currentDayCount);
        const $newBlock = $(newBlockHtml);
        $('#day-selection-container').append($newBlock);

        const newInput = $newBlock.find('.datepicker');
        applyComplexDatepicker(newInput);

        $newBlock.slideDown(200, function () {
            $('#day-selection-container').sortable('refresh');
        });
    }

    function enforceCheckboxState($input, dayNum) {
        console.log("Validating status");
        const dateText = $input.val();
        const $shiftCheckboxes = $(`input[name="day${dayNum}Shift"]`);
        // --- NEW SELECTOR ---
        const $prioritizeCheckbox = $(`#day${dayNum}-prioritize`);
        // --------------------
        const $feedback = $(`#day${dayNum}-shift-feedback`);

        // reset styles
        $input.removeClass('border-red-500 border-green-500');
        $feedback.removeClass(
            'bg-red-200 bg-blue-200 bg-orange-200 text-red-800 text-blue-800 text-orange-800 border-red-400 border-blue-400 border-orange-400 border'
        );

        // EMPTY = user intentionally cleared date
        const checkedShifts = $shiftCheckboxes.filter(':checked').length;
        const shouldClear = !dateText || (dateText && checkedShifts === 0);

        if (shouldClear) {
            $input.val("");

            // Reset Shifts
            $shiftCheckboxes.prop('disabled', false).prop('checked', false);

            // --- NEW: Reset Prioritize Checkbox ---
            $prioritizeCheckbox.prop('checked', false).prop('disabled', true);
            // -------------------------------------

            $feedback.text('');
            if (allSelectedBlockStarts[dayNum]) {
                delete allSelectedBlockStarts[dayNum];
                $('.datepicker').datepicker('refresh');
            }

            $(`label[for="day${dayNum}-shift-day1"]`).text('Day 1');
            $(`label[for="day${dayNum}-shift-day2"]`).text('Day 2');
            return;
        }

        // 2. Handle the "filled" case (VALIDATION)
        const userAssignedShift = window.USER_INFO ? window.USER_INFO.shift : null;
        let dateForCalc;
        let validationError = "";

        try {
            // ... [Validation checks remain the same] ...
            const dateParts = dateText.split('/');
            if (dateParts.length !== 3 || dateParts[2].length !== 4) {
                throw new Error("Invalid format (MM/DD/YYYY).");
            }

            dateForCalc = new Date(dateParts[2], dateParts[0] - 1, dateParts[1]);
            if (isNaN(dateForCalc.getTime())) {
                throw new Error("Invalid date entered.");
            }

            const { shift: selectedShift, blockStartDate } = getShiftAndBlock(dateForCalc);

            if (selectedShift === "Pre-Cycle") {
                throw new Error("Date is before cycle start.");
            }

            if (userAssignedShift && selectedShift !== userAssignedShift) {
                throw new Error(
                    `This date is on Shift ${selectedShift}. Your shift is ${userAssignedShift}.`
                );
            }

            // ✅ VALID
            const formattedDate = formatDate(blockStartDate);
            $input.data('invalid', false);
            $input.val(formattedDate).addClass('border-green-500');

            // Update global state
            allSelectedBlockStarts[dayNum] = blockStartDate;

            const day2Date = new Date(blockStartDate);
            day2Date.setDate(day2Date.getDate() + 1);
            const day1Formatted = formatDate(blockStartDate);
            const day2Formatted = formatDate(day2Date);

            // Update Day 1 Label
            $(`label[for="day${dayNum}-shift-day1"]`).text(day1Formatted);
            // Update Day 2 Label
            $(`label[for="day${dayNum}-shift-day2"]`).text(day2Formatted);
            // ------------------------------------


            $feedback
                .text(`Shift ${selectedShift} – OK`)
                .addClass('bg-blue-200 text-blue-800 border-blue-400');

            $shiftCheckboxes.prop('disabled', false);

            // --- NEW: Enable Prioritize Checkbox ---
            $prioritizeCheckbox.prop('disabled', false);
            // ---------------------------------------

            $('.datepicker').datepicker('refresh');

        } catch (e) {
            // ❌ INVALID – keep the value so row is NOT treated as empty
            $input.data('invalid', true); // ❌ Set invalid flag to true
            validationError = e.message;

            $input.addClass('border-red-500');
            $feedback
                .text(validationError)
                .addClass('bg-red-200 text-red-800 border-red-400');

            // do NOT clear value, do NOT mark block as empty
            // (optional) keep shifts enabled so the row feels editable
            $shiftCheckboxes.prop('disabled', false);

            // --- NEW: Reset Prioritize Checkbox on error ---
            $prioritizeCheckbox.prop('disabled', true).prop('checked', false);
            // ----------------------------------------------

            $(`label[for="day${dayNum}-shift-day1"]`).text('Day 1');
            $(`label[for="day${dayNum}-shift-day2"]`).text('Day 2');
        }
    }


    // --- SPLIT LOGIC ---

    function performSplit(dayNum) {
        const $originalBlock = $(`#day-${dayNum}-selection`);
        const $dateInput = $(`#day${dayNum}-date`);
        const currentDateVal = $dateInput.val();

        if (!currentDateVal) {
            alert("Please select a date before splitting.");
            return;
        }

        const splitId = generateUniqueId();

        // 1. Create & Insert New Block
        const newBlockHtml = createDayBlock(dayNum + 1);
        const $newBlock = $(newBlockHtml);
        $originalBlock.after($newBlock);
        $newBlock.show();

        // 2. POPULATE DATA
        // Set BOTH real inputs to the START DATE (e.g., 11/23)
        const $newInput = $newBlock.find('.datepicker');
        $newInput.val(currentDateVal);

        // 3. STAMP IDs
        $originalBlock.attr('data-split-group', splitId);
        $newBlock.attr('data-split-group', splitId);

        // 4. REORDER
        reorderDayIndices();

        // 5. LOCKDOWN & CONFIGURE
        const $linkedBlocks = $(`div[data-split-group="${splitId}"]`);
        const $topBlock = $linkedBlocks.eq(0);
        const $bottomBlock = $linkedBlocks.eq(1);

        const topIndex = parseInt($topBlock.attr('id').match(/day-(\d+)-selection/)[1]);
        const bottomIndex = parseInt($bottomBlock.attr('id').match(/day-(\d+)-selection/)[1]);

        // --- TOP BLOCK (Day 1) ---
        $(`#day${topIndex}-shift-day1`).prop('checked', true);
        $(`#day${topIndex}-shift-day2`).prop('checked', false);

        // --- BOTTOM BLOCK (Day 2) ---
        const $bottomDateInput = $(`#day${bottomIndex}-date`);
        applyComplexDatepicker($bottomDateInput[0]);

        $(`#day${bottomIndex}-shift-day1`).prop('checked', false);
        $(`#day${bottomIndex}-shift-day2`).prop('checked', true);

        // --- FIX LABELS ---
        // This reads the Real Input (11/23) and sets labels to 11/23 and 11/24 correctly
        enforceCheckboxState($(`#day${topIndex}-date`), topIndex);
        enforceCheckboxState($(`#day${bottomIndex}-date`), bottomIndex);

        // --- RE-APPLY LOCKS & GHOSTS ---
        updateBlockVisuals($topBlock, topIndex);
        updateBlockVisuals($bottomBlock, bottomIndex);

        toggleHalfTourWarning(topIndex);
        toggleHalfTourWarning(bottomIndex);
    }


    function performMerge(dayNum) {
        const $currentBlock = $(`#day-${dayNum}-selection`);
        const splitId = $currentBlock.attr('data-split-group');

        if (!splitId) return;

        // Find partners based on ID
        const $partners = $(`div[data-split-group="${splitId}"]`);

        if ($partners.length < 2) {
            // Orphaned block fallback
            $currentBlock.removeAttr('data-split-group');
            resetBlockToNormal($currentBlock, dayNum);
            reorderDayIndices();
            return;
        }

        // Identify Top and Bottom based on visual DOM order
        // (If user swapped them, eq(0) is the one physically on top)
        const $survivor = $partners.eq(0);
        const $victim = $partners.eq(1);

        // Get the index of the survivor
        const survivorIndex = parseInt($survivor.attr('id').match(/day-(\d+)-selection/)[1]);

        // 1. DELETE THE VICTIM (Bottom block)
        $victim.remove();

        // 2. CLEAN THE SURVIVOR (Top block)
        $survivor.removeAttr('data-split-group');

        // Run the deep clean
        resetBlockToNormal($survivor, survivorIndex);

        // 3. REORDER (Fixes IDs for everything below)
        reorderDayIndices();
    }

    // Helper to make the merge function cleaner
    function resetBlockToNormal($block, dayIndex) {
        const $dateInput = $(`#day${dayIndex}-date`);
        const $ghostInput = $(`#day${dayIndex}-ghost-date`);

        // Unlock Date, Hide Ghost
        $dateInput.prop('disabled', false).removeClass('hidden bg-gray-100 text-gray-500 cursor-not-allowed');
        $ghostInput.addClass('hidden');

        // Unlock Checkboxes
        const $cb1 = $(`#day${dayIndex}-shift-day1`);
        const $cb2 = $(`#day${dayIndex}-shift-day2`);
        $cb1.prop('disabled', false).prop('checked', true).parent().removeClass('opacity-50');
        $cb2.prop('disabled', false).prop('checked', true).parent().removeClass('opacity-50');

        // Reset Buttons
        $(`#btn-split-${dayIndex}`).removeClass('hidden');
        $(`#btn-merge-${dayIndex}`).addClass('hidden');

        // 4. Force Label Refresh
        enforceCheckboxState($dateInput, dayIndex);

        // 5. Update Visuals
        updateBlockVisuals($block, dayIndex);

        // 6. Hide warning
        toggleHalfTourWarning(dayIndex);
    }

    function updateBlockVisuals($block, dayIndex) {
        const isSplit = !!$block.attr('data-split-group');
        const $splitBtn = $(`#btn-split-${dayIndex}`);
        const $mergeBtn = $(`#btn-merge-${dayIndex}`);
        const $dateInput = $(`#day${dayIndex}-date`);
        const $ghostInput = $(`#day${dayIndex}-ghost-date`);

        if (isSplit) {
            // --- SPLIT STATE ---
            $block.removeClass('bg-white border-t').addClass('bg-blue-50 border border-blue-300');
            $splitBtn.addClass('hidden');
            $mergeBtn.removeClass('hidden');
            $block.find('.drag-handle').addClass('bg-blue-100 border-blue-200').removeClass('bg-gray-50 border-gray-200');

            // Determine Top vs Bottom based on which box is checked
            const day1Checked = $(`#day${dayIndex}-shift-day1`).is(':checked');

            if (day1Checked) {
                // --- TOP BLOCK (Day 1 Active) ---

                // Inputs
                $dateInput.prop('disabled', true).removeClass('hidden').addClass('bg-gray-100 text-gray-500 cursor-not-allowed');
                $ghostInput.addClass('hidden');

                // Lock Checkboxes
                // Day 1: Locked but VISIBLE (Remove opacity)
                $(`#day${dayIndex}-shift-day1`)
                    .prop('disabled', true)
                    .parent().removeClass('opacity-50');

                // Day 2: Locked and DIMMED
                $(`#day${dayIndex}-shift-day2`)
                    .prop('disabled', true)
                    .parent().addClass('opacity-50');

            } else {
                // --- BOTTOM BLOCK (Day 2 Active) ---

                // Inputs
                $dateInput.addClass('hidden');
                const realVal = $dateInput.val();
                const displayVal = calculateNextDay(realVal);
                $ghostInput.val(displayVal).removeClass('hidden');

                // Lock Checkboxes
                // Day 1: Locked and DIMMED
                $(`#day${dayIndex}-shift-day1`)
                    .prop('disabled', true)
                    .parent().addClass('opacity-50');

                // Day 2: Locked but VISIBLE (Remove opacity)
                $(`#day${dayIndex}-shift-day2`)
                    .prop('disabled', true)
                    .parent().removeClass('opacity-50');
            }

        } else {
            // --- NORMAL STATE ---
            $block.addClass('bg-white border-t').removeClass('bg-blue-50 border border-blue-300');
            $splitBtn.removeClass('hidden');
            $mergeBtn.addClass('hidden');
            $block.find('.drag-handle').removeClass('bg-blue-100 border-blue-200').addClass('bg-gray-50 border-gray-200');

            // Unlock Inputs
            $dateInput.prop('disabled', false).removeClass('hidden bg-gray-100 text-gray-500 cursor-not-allowed');
            $ghostInput.addClass('hidden');
        }
    }

    // Helper
    function calculateNextDay(dateStr) {
        try {
            const parts = dateStr.split('/');
            const d = new Date(parts[2], parts[0] - 1, parts[1]);
            d.setDate(d.getDate() + 1);
            const mm = (d.getMonth() + 1).toString().padStart(2, '0');
            const dd = d.getDate().toString().padStart(2, '0');
            const yyyy = d.getFullYear();
            return `${mm}/${dd}/${yyyy}`;
        } catch (e) { return dateStr; }
    }

    // Helper for the split function date conversion
    function convertDateToIso(dateStr) {
        // Converts MM/DD/YYYY to YYYY-MM-DD or Date Object string for the loader
        const parts = dateStr.split('/');
        return new Date(parts[2], parts[0] - 1, parts[1]).toString();
    }

    function generateUniqueId() {
        return 'split_' + Math.random().toString(36).substr(2, 9);
    }

    /**
     * Fills data into a specific date block and ensures the global state is updated.
     * This is called by fillPreviousPicks.
     * @param {string} dateText - The RAW date string (e.g., "Fri Feb 06 2026...").
     * @param {string} shiftsString - Comma-separated shifts (e.g., "Day1, Day2").
     * @param {number} dayIndex - The day number (1, 2, 3...)
     */
    function loadPickIntoDayBlock(dateText, shiftsString, dayIndex, prioritizeLater = false) {
        const $dateInput = $(`#day${dayIndex}-date`);

        // --- FIX A: PARSE AND FORMAT THE DATE ---
        let blockStartDate;
        let formattedDate;
        try {
            // 1. Create a Date object from the raw string
            blockStartDate = new Date(dateText);

            // 2. Format it to MM/DD/YYYY
            // We'll add a simple formatter here to be safe
            let month = (blockStartDate.getMonth() + 1).toString().padStart(2, '0');
            let day = blockStartDate.getDate().toString().padStart(2, '0');
            let year = blockStartDate.getFullYear();
            formattedDate = `${month}/${day}/${year}`;

        } catch (e) {
            console.error(`Could not parse date ${dateText} for day ${dayIndex}.`, e);
            $dateInput.val("INVALID DATE"); // Show an error
            return; // Stop
        }
        // ------------------------------------

        // 1. Set the *formatted* date value in the input field
        $dateInput.val(formattedDate);

        // 2. Set the global selection state (using the Date object)
        allSelectedBlockStarts[dayIndex] = blockStartDate;

        // 3. Set checkboxes (This will run now that the date parsing is fixed)
        const shiftsArray = shiftsString.split(',').map(s => s.trim());

        $(`input[name="day${dayIndex}Shift"]`).prop('checked', false);
        shiftsArray.forEach(shiftValue => {
            $(`input[name="day${dayIndex}Shift"][value="${shiftValue}"]`).prop('checked', true);
        });

        toggleHalfTourWarning(dayIndex);

        // --- NEW: Set Prioritize Checkbox ---
        if (prioritizeLater) {
            $(`#day${dayIndex}-prioritize`).prop('checked', true);
        }
        // ------------------------------------

        // 4. Force enforcement/feedback update
        enforceCheckboxState($dateInput, dayIndex);
    }


    function fillPreviousPicks(picksRow) {

        // --- SET ACKNOWLEDGMENT (Existing logic remains) ---
        var acknowledgment = picksRow[7];
        if (acknowledgment) {
            $(`input[name="formCompletion"][value="${acknowledgment}"]`).prop('checked', true);
            $('input[name="formCompletion"]').trigger('change');
        }
        // -----------------------------------------------------------

        var START_PICK_INDEX = 9; // Index of Day 1 column (Column J)
        var pickCount = 0;

        // We iterate through the picksRow, jumping 2 columns at a time.
        for (var i = START_PICK_INDEX; i < picksRow.length; i += 2) {
            var dateText = picksRow[i]; // This is the RAW date string
            var shiftString = picksRow[i + 1]; // e.g., "Day1, Day2"

            // Stop if the date column is empty
            if (!dateText) break;

            pickCount++;

            // Check to ensure we don't exceed the max (safety)
            if (pickCount > MAX_DAYS) break;

            // A. Handle Day 1 (which is already in the DOM)
            if (pickCount === 1) {
                loadPickIntoDayBlock(dateText, shiftString, 1);
            } else {
                // B. Handle Day 2 and subsequent days:
                // The Day 1 block is already visible, but Day 2/3/etc. slots MUST be created.
                addNewDayBlock(); // Creates the slot for pickCount=2, 3, 4, etc.

                // loadPickIntoDayBlock uses currentDayCount, which was just incremented by addNewDayBlock
                loadPickIntoDayBlock(dateText, shiftString, currentDayCount);
            }
        }

        // --- CRITICAL FIX: Add ONLY the single blank day after the loop ends ---
        // This is the clean, single slot the user needs to interact with next.
        // It runs regardless of whether pickCount is 1 or 5, ensuring a single blank line.
        if (currentDayCount < MAX_DAYS) {
            addNewDayBlock();
        }
        // ------------------------------------------------------------------

        // CRITICAL: Refresh all datepickers to show the correct global highlights
        $('.datepicker').datepicker('refresh');
    }






    // SINGLE CHANGE HANDLER - manages all empty row logic
    $('#day-selection-container').off('change').on('change', 'input', function () {
        console.log("Detected change through formLogic!");
        // Debounce to prevent multiple rapid calls
        clearTimeout(window.emptyRowTimeout);
        window.emptyRowTimeout = setTimeout(manageEmptyRows, 50);
    });

    // Robust empty row management function
    function manageEmptyRows() {
        console.log("Running ManageEmptyRows()")
        const $container = $('#day-selection-container');
        const $allBlocks = $container.find('.day-selection-block');

        let emptyBlocks = [];
        let filledBlocks = [];

        // Categorize all blocks
        $allBlocks.each(function () {
            const $block = $(this);
            const $dateInput = $block.find('input[id$="-date"]');
            const hasDate = $dateInput.val().trim() !== '';
            const hasCheckedShifts = $block.find('input[type="checkbox"]:checked').length > 0;
            console.log({ date: $dateInput.val().trim(), checked: $block.find('input[type="checkbox"]:checked').length > 0 })
            if (!hasDate) {
                emptyBlocks.push($block);
            } else {
                filledBlocks.push($block);
            }
        });

        console.log(`Found ${emptyBlocks.length} empty blocks, ${filledBlocks.length} filled blocks`);

        // Remove excess empty blocks (keep only the first one)
        if (emptyBlocks.length > 1) {
            for (let i = 1; i < emptyBlocks.length; i++) {
                console.log(`Removing excess empty block ${i}`);
                emptyBlocks[i].remove();
            }
            emptyBlocks = [emptyBlocks[0]]; // Keep only the first
        }

        // If no empty blocks exist and we haven't reached max, add one
        if (emptyBlocks.length === 0 && $allBlocks.length < MAX_DAYS) {
            console.log('No empty blocks found, adding one');
            addNewDayBlock();
        }

        // Reorder indices after any changes
        reorderDayIndices();
    }

    // Reorder day indices after sorting
    // Reorder day indices after sorting
    function reorderDayIndices() {
        console.log("reorderDayIndicies");

        const newAllSelectedBlockStarts = {};

        $('#day-selection-container .day-selection-block').each(function (index) {
            const newIndex = index + 1;
            const $block = $(this);

            // 1. Store the old date value before changing IDs
            const $dateInput = $block.find('input[id$="-date"]');
            const dateValue = $dateInput.val();

            // Update block ID
            $block.attr('id', `day-${newIndex}-selection`);

            // Update Split/Merge Buttons
            const $splitBtn = $block.find('button[id^="btn-split-"]');
            $splitBtn.attr('id', `btn-split-${newIndex}`).attr('onclick', `performSplit(${newIndex})`);

            const $mergeBtn = $block.find('button[id^="btn-merge-"]');
            $mergeBtn.attr('id', `btn-merge-${newIndex}`).attr('onclick', `performMerge(${newIndex})`);

            // --- FIX 1: UPDATE WARNING DIV ID ---
            // Ensure the warning box belongs to this row index
            const $warningDiv = $block.find('div[id^="warning-"]');
            if ($warningDiv.length) {
                $warningDiv.attr('id', `warning-${newIndex}`);
            }

            // --- FIX 2: UPDATE CHECKBOX LISTENERS (The Critical Fix) ---
            // We must update the onchange attribute so it passes the NEW index
            const $checkboxes = $block.find('input[type="checkbox"]');
            $checkboxes.attr('onchange', `toggleHalfTourWarning(${newIndex})`);
            // -----------------------------------------------------------

            // Update all IDs and names in the block (Inputs, Labels, Spans)
            $block.find('input, label, span').each(function () {
                const $el = $(this);
                const oldId = $el.attr('id');
                const oldName = $el.attr('name');
                const oldFor = $el.attr('for');

                if (oldId) {
                    $el.attr('id', oldId.replace(/day\d+/, `day${newIndex}`));
                }
                if (oldName) {
                    $el.attr('name', oldName.replace(/day\d+/, `day${newIndex}`));
                }
                if (oldFor) {
                    $el.attr('for', oldFor.replace(/day\d+/, `day${newIndex}`));
                }
            });

            // Update shift selection labels text
            $block.find('label:contains("Shift Selection")').text(`Shift Selection ${newIndex}`);

            // 2. Reconstruct new allSelectedBlockStarts map
            if (dateValue) {
                try {
                    const dateParts = dateValue.split('/');
                    const parsedDate = new Date(dateParts[2], dateParts[0] - 1, dateParts[1]);
                    if (!isNaN(parsedDate.getTime())) {
                        newAllSelectedBlockStarts[newIndex] = parsedDate;
                    }
                } catch (e) {
                    console.error(`Re-indexing failed`, e);
                }
            }

            // 3. Force Visual Update
            updateBlockVisuals($block, newIndex);
        });

        // 4. Update global state
        currentDayCount = $('#day-selection-container .day-selection-block').length;
        allSelectedBlockStarts = newAllSelectedBlockStarts;

        // 5. Refresh Datepickers
        $('.datepicker').each(function () {
            const $input = $(this);
            if ($input.data('datepicker')) {
                $input.datepicker('destroy');
            }
            applyComplexDatepicker(this);
        });
    }

    function toggleHalfTourWarning(dayNum) {
        const checkbox1 = document.getElementById(`day${dayNum}-shift-day1`);
        const checkbox2 = document.getElementById(`day${dayNum}-shift-day2`);
        const warningDiv = document.getElementById(`warning-${dayNum}`);
        // Check if this row is part of a split group
        const isSplit = $(`#day-${dayNum}-selection`).attr('data-split-group');

        if (!checkbox1 || !checkbox2 || !warningDiv) return;

        // If it's a split block (Blue), ALWAYS hide the warning.
        // The user knows it's a half tour because they explicitly split it.
        if (isSplit) {
            warningDiv.classList.add('hidden');
            return;
        }

        // Otherwise, standard logic:
        const count = (checkbox1.checked ? 1 : 0) + (checkbox2.checked ? 1 : 0);

        if (count === 1) {
            warningDiv.classList.remove('hidden');
        } else {
            warningDiv.classList.add('hidden');
        }
    }

    /**
     * This is the main function called from Form_Refactored.html
     */
    function initializeDatepicker() {
        // init sortable for future blocks
        $('#day-selection-container').sortable({
            handle: '.drag-handle',
            axis: 'y',
            containment: 'parent',
            tolerance: 'pointer',
            items: '.day-selection-block',
            update: reorderDayIndices
        });

        // (your delegated change handler for manageEmptyRows can stay as-is)

        // bootstrap Day 1 dynamically
        addNewDayBlock();   // creates #day1-selection + #day1-date and wires datepicker
    }

</script>